\documentclass[14pt,a4paper, titlepage]{article}

\usepackage{graphicx}
\usepackage{url}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{csquotes}

\lstset{
    literate={~} {$\sim$}{1}
}


\begin{document}
\setcounter{page}{3}
\newcommand{\dlvhex}{{\sc dlvhex}}
\newcommand{\hex}{{\sc hex}}
\setcounter{secnumdepth}{4} % how many sectioning levels to assign numbers to
\setcounter{tocdepth}{4}    % how many sectioning levels to show in ToC

\begin{titlepage}
    \centering
    \vfill
    \includegraphics[width=15cm,height=6cm]{biglogo_whitebg}
    \vfill
    {\bfseries\Large
        User Guide
        \vskip4cm
        Christoph Redl\vskip1cm Mustafa Mehuljic
    }    
    
\end{titlepage}

% Abstract part
\begin{abstract}
This document provides a user guide for the Answer Set Programming(ASP) system called \dlvhex{} developed at Vienna University of Technology. ASP is a declarative problem solving paradigm, rooted in Logic Programming and Nonmonotonic Reasoning, which has been gaining increasing attention during the last years. The \dlvhex{} system is a logic-programming reasoner for computing the models of so-called \hex{}-programs, which are an extension of \textbf{answer-set programs} towards integration of \textbf{external computation sources}. This guide aims at enabling users of this system to interoperate with a broader set of external computation sources. The guide refers to release 2.4.     
\end{abstract}

% Generates table of contents
\tableofcontents

\newpage

\section{Introduction} % Section No.1
The \dlvhex{} system is a logic-programming reasoner for computing the models of so-called \hex{}-programs, which are an extension of \textbf{answer-set programs} towards integration of \textbf{external computation sources}. To enable access to external information, \hex{}-programs extend programs with external atoms, which allow for a bidirectional communication between the logic program and external sources of computation (e.g., description logic reasoners and Web resources)\cite{extatoms}. The system is developed motivated by the need to interoperate with a broader set of external computation sources and the observation, that for meta-reasoning in the context of the Semantic Web, no adequate support is available in ASP to date. To overcome this,\hex{}-programs have been introduced, which support higher-order logic programs (which accommodate meta-reasoning through higher-order atoms) with external atoms for software interoperability.

This guide helps ASP novices to make use of the system with all its features. It provides a reference of the features of the tool that ASP might be tempted to exploit. The language of \hex{}-programs is an extension of disjunctive datalog. It largely implements the ASP-Core-2 Standard \cite{ref} and extends it with external atoms. 

In this guide we try explain the fundamentals of using \dlvhex{} to make that reader benefit from them by significantly reducing the time to solve difficult computational problems. 


\subsection{Download and Installation}
\dlvhex{} is written in C++ programming-language and it is published under GNU Lesser General Public License \cite{licnc}. In this section we provide overview of the download and installation process. For a quick overview, some examples and the possibility to evaluate \hex{}-programs directly in the browser, the online demo at \cite{onlinedemo} is provided. However the system can also be installed locally. 
\subsubsection{Building from source}
There are two possibilities to install \dlvhex{} system from source. One possibility is to install latest stable release of the system or to install latest development version which may not be stable. Both ways are described in following section.  
\paragraph{Latest release version (tarball)}
Packages (tarballs) of \dlvhex{} can be downloaded from the project page\cite{sourceforge}. The latest release of the software runs on Linux-based systems,Mac OS X and Microsoft Windows. The latest stable release version of the \dlvhex{} can be found at \url{http://sourceforge.net/projects/dlvhex/files/}. Installation instructions are given in the {\tt INSTALL} and {\tt README} files of the \dlvhex{} and plugin source directories. Changes between versions can be found in the {\tt NEWS} files and in detail in the {\tt ChangeLog} file.
\\ After downloading latest release version by executing following sequence of commands \dlvhex{} will be successfully installed on your system.
\\ \centerline{\texttt{./configure}} After successful download one have to run configure script in order to check and install all missing libraries. It will prepare system for the building. If you want to use python features in \dlvhex you can enable it by typing \texttt{-enable-python \$dlvhexoptions} as option for configure.
\\ \centerline{\texttt{make}} When system is ready for building we will execute make command which will do it. To allow using of multiple cores one should specify -j option to make as well as number of cores which can be used.
\\ \centerline{\texttt{make install}} This installs the package in the place specified with configure.  
   
\paragraph{Development version (git clone)}
The source code of \dlvhex{} is hosted on github at \url{https://github.com/hexhex/}. If you want to build software from the source \dlvhex{} uses the standard \\ \centerline{./configure, make and make install} commands from the shell once all dependencies are resolved. The system requires the following packages: git, gcc (version 4.8 or later), g++ (version 4.8 or later), libbz2-dev, Python (version 2.7 or later), bison, scons, cmake, automake, autoconf, libstdc++ (version 4.8 or later), libcurl4 and libool. Also Boost Library (version 1.55 or later) is required. Latest Boost Library version is available at \url{http://www.boost.org/}. After downloading it to the new folder the following steps should be followed in order to properly install Boost Library. Downloaded file should be moved to the folder where Boost Library will be installed. Extract it there and execute following commands:
%\\ \\sudo ./bootstrap.sh $\&\&$ $./b2$ --python-enable --layout=tagged --build-type=complete\\ --threading=multi --prefix=\$ %boostdir install -j4 \\ 
\\ \centerline{\texttt{./bootstrap.sh}}
Running bootstrap script will download and install all dependencies required.
\centerline{\texttt{./b2 install --prefix=PREFIX}} After running bootstrap script we will execute this command. In this command PREFIX is a directory where you want Boost.Build to be installed.  
\\ \\Now when all dependencies are satisfied we can simply git clone system from the \url{https://github.com/hexhex/core --recursive} to get most recent developed version. Shell command to do this
\\ \\ \centerline{\texttt{git clone https://github.com/hexhex/core --recursive}} 
\\ \\After cloning to the desired directory it is necessary to execute bootstrap.sh script from there invoking \\ \centerline{\texttt{./bootstrap.sh}}. 
\\ \\After cloning and bootstrapping latest release version, same steps as in Section 1.1.1.1 (configure, make and make install) will be followed in order to complete installation.  \\ \\We provide a script which should install \dlvhex{} automatically on your system. You can find script at \url{https://github.com/hexhex/core/blob/master/scripts/setupdlvhex.sh}.\\Once installation is completed,the system can be used from the terminal as follows:\\ 
\centerline{\textbf{shell\$ dlvhex2 program.hex}} where program.hex refers to the input program. Various additional options are available and explained in following sections.    

\subsubsection{Pre-built binaries}
We provide pre-built binaries of \dlvhex{} for some systems. For details see our website \url{http://www.kr.tuwien.ac.at/research/systems/dlvhex/index.html}. 


\subsection{Outline}
This guide is organized as follows: Section 2 provides an introductory example which will be used to explain problem instance, encoding and its solution. Section 3 is focused on input language of the \dlvhex{}. In Section 4 we introduced three real life problems which can be solved using our system. Section 5 is focused on description of external interfaces which are written in C++ and Python. Input-related warnings and errors are described into more details in Section 6. And finally in Section 7 we describe possible future work that may be considered.

\section{Quickstart} % Section No.2



\subsection{Problem Instance}
\subsection{Problem Encoding}
\subsection{Problem Solution}
\subsection{Summary}

\newpage
\section{Input Language}% Section No. 3
This section provides an overview of the input language of \dlvhex{} and provide some examples to illustrate concept. Vocabulary: terms, predicates, constants, variables and external predicates.   
\subsection{Terms}
Terms may be integers, constants, strings and variables as well as the \enquote{\_} tokens. Constant names begin with lowercase leters and variable names begin with uppercase letters. \\ While a constant or string represent itself, a variable is placeholder for all variable-free terms in the language of a logic program. There is a special feature, which is called anonymous variable. The anonymous variable is denoted by "\_" (the underscore) and is different from a usual variable. Each occurrence of \enquote{\_} represents a new and unique variable, which does not occur anywhere else in the same rule. this might be used to specify that an argument can be ignored or does not matter.
\\ \textbf{Example 3.1.} 
Terms are:
\\ \texttt{Constants:} a, 1, a1, 9862, c1
\\ \texttt{Variables:} X, Y, Z, V2f
\\ \texttt{Atoms:} a, b, deaf, smart
\\ \texttt{Predicates:} parent(X,Y), employee(name, salary, ID, location)
       

\subsection{Normal Programs and Integrity constraints}
\dlvhex{} is a declarative (programming) language. This means that programmer does not write an algorithm that solves some problem but instead specifies what the solution should look like, and then solves the problem and finds solution itself. Each normal logic program is constructed using \textbf{facts, rules and integrity constraints}. 
\\ \\ \texttt{Fact:} $ A_0. $ 
\\ \texttt{Rule:} $ A_0 $ :-  $L_1$,\dots,$L_n$.
\\ \texttt{Constraint:}   :- $ L_1$,\dots,$L_n$.
\\ \\Facts are always true. The sign \enquote{:-} is meant to be an implication to the left. The left side of a rule is called its \texttt{head}, and right side is called its \texttt{body}. The \texttt{head} $A_0$ of a rule or a fact is an atom of the same syntatic form as a constant or function. In the \texttt{body} of a rule or an integrity constraint, every $L_j$ for 1 $\leq$ j $\leq$ n is a literal of the form A or \texttt{not} A, where A is an atom and the connective \texttt{not} denotes default negation. We say that literal L is positive if it is an atom and negative otherwise. While the head atom $A_0$ of the fact must unconditionally be true, the intuitive reading of a rule corresponds to an implication: if all positive atoms in the rule body are true and negated atoms are false, then $A_0$ must be true. On the other hand, an integrity constraint is a rule that filters solution candidates, meaning that the literals in its body must not jointly be satisfied. A result of \dlvhex{} computation is called a \textit{model}. The meaning of this is clear: it is a consistent explanation(model) of the world, as far as it system can derive it. If \dlvhex{} cannot find solution then there is no model for the given problem. \\ \textbf{Example 3.1.} \medskip \\Consider the following logic program:\lstinputlisting{example_3.1.hex} The first line here represents an atom which is always true. The second line is a rule and reads as \enquote{If joke is true, laugh must also be true}. Also we can read this as \enquote{from joke follows laugh}. The single model of above program is $\{joke, laugh\}$ since they are the atoms which are true in the program. \\To explain the concept of \texttt{integrity constraints} we will consider following example:\medskip \\ \textbf{Example 3.2.}
\lstinputlisting{example_3.2.hex}
In the first three lines one can see node declarations with variables X and Y. We concluded that X and Y are variables since they begin with uppercase letter. It says that: \enquote{If edge(X,Y) is true then node(X) is also true}. That is, it extracts the nodes from a graph specified by its edges. In the \texttt{guessing part} \dlvhex{} will list all possible models for the node(X). Each node may be coloured with either red, green or black. We did not see construction as in checking part before. It is called as \texttt{integrity constraint.} Integrity constraints in our framework specify conditions which must not become true in any model. In other words, constraints are formulations of possible inconsistencies. This mechanism is very useful in connection with disjunctive rules. The disjunctive rules serve as generators for different models and the constraints are used to select only the desired ones. Integrity constraint for this particular case will delete all those atoms from the model which does not satisfy our requirement(that there may be no edge between two nodes of equal color). Another important feature of \dlvhex{} is \texttt{default negation}. Negation is treated as "negation as failure". In other words: If an atom is not true in some model, then its negation should be considered to be true in that model. With this mechanism we can, for example, define the complementary graph of a given graph. This is the graph which has the same nodes, but of all possible edges, it has exactly those edges which do not exist in the original graph. \newpage
\begin{lstlisting}
node(X) :- edge(X,_).
node(Y) :- edge(_,Y).

comp_edge(X,Y) :- node(X), node(Y), not edge(X,Y).
\end{lstlisting}
Here \texttt{comp\_edge} describes the set of edges in the complementary graph. Such an edge must go from one node to another node (possibly the same one), and this edge must not be contained in the original edge set. Note that node(X) and node(Y) need to be included in the body in order to satisfy the following safety requirement for rules: Variables, which occur in a negated literal, must also occur in a positive literal in the body.

\subsection{Classical Negation}
\dlvhex{} supports two kinds of negation. Here we will emphasize difference between explicitly expressing falseness of an atom and having it done by \texttt{Complete World Assumption}. The connective \texttt{not} expresses default negation, i.e. a literal \texttt{not A} is assumed to hold unless atom A is derived to be true. In contrast, the classical (or strong) negation of an atom holds only if it can be derived. In other words if there is no evidence that an atom is true, it is considered to be false. Classical negation, indicated by symbol \enquote{-}, is permitted in from of an atoms. The semantic relationship between A and -A is simply that they must not jointly hold. 
\\ \textbf{Example 3.3.}
\\ Imagine a simple situation, in which and agent has to cross a railroad. The agent should cross it if there is no train approaching. With this description, one might specify the following program:
\begin{lstlisting}
 cross_railroad :- not train_approaches.
\end{lstlisting}
The following program has the model \textit{cross} because $train\_approaches$ is assumed to be false(as it being true is not stated anywhere). This kind of negation is called negation as failure.\\The next program uses so-called true or classical negation. Since \textit{$-train\_approaches$} is not known to be true, the following program has only an empty model.
\begin{lstlisting}
 cross_railroad :- -train_approaches.
\end{lstlisting}
The difference between the two kinds of negation is quite important: In the first example, we cross the railroad track if we have no information on any trains approaching, which is quite dangerous, while in the second example, we only cross if we know for sure that no train comes. It is important to note that classical negation is stronger than negation as finite failure. If something is true via true negation, it is always also true if negated by negation as failure.

\subsection{Disjunction}
Disjunctive logic programs permit the connective 'v' between atoms in rule heads.
\\ \texttt{Fact:} $A_0$ v \dots v $A_m$
\\ \texttt{Rule:} $A_0$ v \dots v $A_m :- L_1,\dots,L_n. $
\\ The \texttt{head} $A_0$ of a rule or a fact is an atom of the same syntatic form as a constant or function. In the \texttt{body} of a rule or an integrity constraint, every $L_j$ for 1 $\leq$ j $\leq$ n is a literal of the form A or \texttt{not} A, where A is an atom and the connective \texttt{not} denotes default negation. We say that literal L is positive if it is an atom and negative otherwise. While the head atom $A_0$ of the fact must unconditionally be true, the intuitive reading of a rule corresponds to an implication: if all positive atoms in the rule body are true and negated atoms are false, then $A_0$ must be true. A \texttt{disjunctive head} holds if at least one of its atomes is true. In a simple disjunctive program \texttt{a v b.} we have the two answer sets \{a\} and \{b\}.
\\ \textbf{Example 3.4.}
\begin{lstlisting}
left_arm_broken v right_arm_broken.
can_write :- left_arm_broken.
be_angry :- can_write
\end{lstlisting}
Suppose you have met a friend recently and know that he had one of his arms broken, but do not know which one. Now suppose we did not receive a greeting card for your birthday and wonder if you should be angry on him or he just could not write because his right hand is broken. In example, \dlvhex{} will generate two possible explanations. The first rule is called a disjunctive rule; the v is read as \enquote{or} and the whole rule is read as \enquote{For sure, either the left or the right arm is broken.} Without being sure which arm is broken \dlvhex{} will evaluate the program and produce the two models \texttt{$\{left\_arm\_broken, can\_write, be\_angry$\}} and \texttt{$\{right\_arm\_broken$\}}.  

\subsection{Built-in Arithmetic Functions}
Beside integers (constant arithmetic functions), written as sequence of digits 0 \dots 9, \dlvhex{} supports other types of arithmetic functions. We are using the following operators for those functions: + (addition), - (subtraction), * (multiplication), / (integer division). \\ \textbf{Example 3.5.}
\begin{lstlisting}
% This example demonstrates usage of built-in arithmetic functions
a(6).
b(2).

c(X,Y,XX) :- a(X), b(Y),+(X, Y, XX).
d(X,Y,XX) :- a(X), b(Y),-(X, Y, XX).
e(X,Y,XX) :- a(X), b(Y),*(X, Y, XX).
f(X,Y,XX) :- a(X), b(Y),/(X, Y, XX).
\end{lstlisting}
The single answer set for the example above is: \\ \texttt{\{a(6),b(2),e(6,2,12),f(6,2,3),c(6,2,8),d(6,2,4)\}}
\\Except \texttt{prefix notation} we can also use \texttt{infix notation} to use built-in arithmetic functions in \dlvhex{}. Instead of writing +(X, Y, XX) alternatively we can write it as XX=X+Y. 
     
\subsection{Built-in Comparison Predicates}
\dlvhex{} feature a total order among variable-free terms using built-in predicates == (equal), != (not equal), $<$ (less than), $\leq$ (less than or equal), $>$ (greater than) and $\geq$ (greater than or equal). All kinds of constants (symbols and integers) may be compared against each other freely. If two integers are compared, the semantics are as expected. All other comparisons are just guaranteed to impose a fixed ordering over all constants. The application of comparison literals to integers is illustrated by the following example.
\\ \textbf{Example 3.6.}
\begin{lstlisting}
% This example demonstrates usage of built-in 
% comparison predicates

a(1).
a(2).
b(1).

c(X,Y) :- a(X), b(Y), X <> Y.
d(X,Y) :- a(X), b(Y), X != Y.
e(X,Y) :- a(X), b(Y), X < Y.
f(X,Y) :- a(X), b(Y), X > Y.
g(X,Y) :- a(X), b(Y), X <= Y.
h(X,Y) :- a(X), b(Y), X >= Y.
i(X,Y) :- a(X), b(Y), Y == 1.
\end{lstlisting}
The single answer set for the example above is:\\ \texttt{\{a(1),a(2),b(1),i(1,1),i(2,1),c(2,1),d(2,1),f(2,1),g(1,1),h(1,1),h(2,1)\}}


\subsection{Conditions and Conditional Literals}
A \textit{conditional literal} is of the form \\ \centerline{$L_0:L_1,\dots,L_n$} where every \textit{$L_j$ for 0 $\leq$ j $\leq$ n} is a literal, $L_1,\dots,L_n$ is called \textit{condition}, and \enquote{:} resembles mathematical set notation. Whenever \texttt{n = 0}, it is a regular literal and we denote it usually by $L_0$.
\\For example, the rule \\ \texttt{a :- b : c.} \\yields \texttt{a} whenever either \texttt{c} is false (whether \texttt{b} holds or not) or both \texttt{b} and \texttt{c} are true \cite{pott}. \\Together  with variables, conditions allow for specifying collections of expressions within a single rule or aggregate. This is particularly useful for encoding conjunctions(or disjunctions) over arbitrarily many ground atoms as well as for the compact representation of aggregates. 
\\ \textbf{Example 3.7.}
\begin{lstlisting}
% This example demonstrates usage of conditions in rule's 
% head and body

person(jane). person(john).
day(mon). day(tue). day(wed). day(thu). day(fri).
available(jane) :- not on(fri).
available(john) :- not on(mon), not on(wed).
meet :- available(X) : person(X).
on(X) : day(X) :- meet.
\end{lstlisting}  
We have used conditions in last two lines of the code. The conjunction in the body of line 5 is obtained by replacing X in \texttt{available(X)} with all ground terms \texttt{t} such that \texttt{person(t)} holds, namely, with t=jane and t=john. The condition for the last line is contained in the head of rule. It turns into disjunction over all ground instances of \texttt{on(X)} such that X is substituted by terms t for which \texttt{day(t)} holds. Any variable occurring within a condition does not count as a positive occurrence outside the condition in the sense of safety. A variable X in an aggregate-free rule is safe if at least one of the following conditions is satisfied:\\-X occurs in a positive standard predicate in the body of the rule;\\-X occurs in a true negated standard predicate in the body of the rule;\\-X occurs in the last argument of an arithmetic predicate A and all other arguments of A are safe. \\ \\A rule is safe if all its variables are safe. Variables occurring in atoms not subject to any conditions are global. Each variable within an atom in front of a condition must be global or have a positive occurrence on the right hand-side of the condition. During grounding, the instantiation of global variables take precedence over non-global ones, that is, the former are instantiated before the latter.As a consequence, variables that occur globally are substituted by terms before a condition is further evaluated \cite{pott}.    
\subsection{Aggregates}
Aggregates allow to express properties over set of elements. DLV and \hex{}-programs with aggregates often allow clean and concise problem encodings by minimizing the use of auxiliary predicates and recursive programs, and help the programmers to depict problems in a more natural way. For instance, we may state that the sum of a semester's course credits must be at least 20, or that the sum of shopping items must not exceed 30 Euros. We can say that an aggregate is a function on a set of tuples that are normally subject to conditions. By comparing an aggregated value with given values, we can extract a truth value from an aggregate's evaluation, thus obtaining an aggregate atom 
They can occur in the bodies of rule and constraints, possibly negated using negation-as-failure. \\ \texttt{Body Aggregates} The form of an \texttt{aggregate atom} occuring in a rule body is as follows:\\ \centerline{$s_1 \prec_1 \alpha \{ t_1:L_1;...;t_n:L_n\} \prec_2 s_2$} 
\\ Here, all \texttt{$t_i$} and \texttt{$L_i$}, forming \texttt{aggregate elements}, are non-empty tuples of terms and literals, respectively. $\alpha$ is the name of some function that is applied to the term tupples \texttt{$t_i$} that remain after evaluating the conditions expressed by $L_i$. Finally,  the result of applying $\alpha$ is compared by means of the comparison predicates $\prec_1 or \prec_2$ to the terms $s_1$ and $s_2$ respectively. \#count, \#sum, \#times, \#min, and \#max are called aggregate functions, and \dlvhex{} currently supports exactly these five. An aggregate function is applied over a set and returns a numeric value.
\\ \textbf{Example 3.8.}
\begin{lstlisting}
% This example demonstrates usage of aggregate functions:
% Each employee is is represented by a fact of the form 
% emp(ID,NAME,SALARY)

emp(1,goofie,1250).
emp(2,willy,700).
emp(3,woody,750).
emp(4,jerry,900).
emp(5,tom,1050).
\end{lstlisting}
Intuitively the symbolic set appearing in the aggregate predicate consists of two ground predicates: \\ \centerline{$\{<1,over1000(1,1250)>,<5,over1000(5,1050)>\}$}
\\which are both true w.r.t. the unique model of the whole program, hence \\ \centerline{$ \#count\{over1000(1,1250),over1000(5,1050)\}$} \\returns 2 as output of aggregate function and outputs:\\ \texttt{(1,goofie,1250),emp(2,willy,700),emp(3,woody,750),emp(4,jerry,900),\\emp(5,tom,1050),over1000(1,1250),over1000(5,1050),over1000nr(2)}
\\as a result of the program.
The aggregate function \texttt{\#count} returns the cardinality of the symbolic set to which it is applied. We want to count how many employees of the company earn more than 1000. 
\begin{lstlisting}
over1000(I,S) :- emp(I,N,S), S > 1000.
over1000nr(X) :- #count{I : over1000(I,W)} = X, #int(X).
\end{lstlisting}
\bigskip Let $f(S)$ be an aggregate function. A variable, X, is a \texttt{local variable} to $f(S)$ if and only if X appears in S and X does not appear in any aggregate function that is outer to $f(S)$. Aggregate function \texttt{\#sum} returns the sum of the first local variable to be aggregated over in the symbolic set. Suppose we want to know how much the Cartoon Co. spends on salaries.
\begin{lstlisting}
salaryTotal(X) :- #sum{S,I : emp(I,N,S)} = X.
\end{lstlisting}
The symbolic set here consists of 5 elements, namely all of the facts stored in the database of the employees. The aggregate function applied to the given set returns the sum of the salaries of all the employees, the output thus is:
{salaryTotal(4650)}. \textbf{\#times} is similar to \#sum, but computes the product of the first local variable to be aggregated over in the symbolic set. When applied over the empty set, \#times returns 1.
\bigskip \\The aggregate function \textbf{\#min} returns the minimum value of the first local variable to be aggregated over in the symbolic set. The following simple program then returns the lowest income among all employees.
\begin{lstlisting}
lowest(X) :- #min{S : emp(I,N,S)} = X.
\end{lstlisting}
The aggregate function applied to the given set returns the minimum salary among of all the employees, the output thus is:
{lowest(700)}
\bigskip \\ The aggregate function \textbf{\#max} returns the maximum value of the first local variable to be aggregated over in the symbolic set. The following program computes the maximum income earned in the company
\begin{lstlisting}
highest(X) :- #max{S : emp(I,N,S)} = X.
\end{lstlisting}
and it outputs $\{highest(1250)\}$ as a highest income in the company.

\subsection{Optimization}
Introducing \texttt{weak constraints} into \hex-programs allows us to formulate several optimization problems in an easy and natural way. These weak constraints are adopted from \texttt{DLV}. While standard constraints (integrity constraints, strong constraints) always have to be satisfied, weak constraints should be satisfied if it is possible, but their violation does not \enquote{local variable} the models.\\The answer sets of a program P with a set W of weak constraints are those answer sets of P which minimize the violation of weak constraints respecting their weights and levels. They are called best models of (P,W). Note that a program may have several best models.\\ Weak constraints can be weighted according to their importance (the higher the weight, the more important the constraint). In the presence of weights, best models minimize the sum of the weights of the violated weak constraints. Weak constraints can also be prioritized. Under prioritization, the semantics minimizes the violation of the constraints of the highest priority level first; then the lower priority levels are considered one after the other in descending order. Syntactically, weak constraints are specified as follows. \\ \centerline{$:~ Conj. [Weight:Level]$} \\ where Conj is a conjunction of (possibly negated) literals, and both Weight and Level are positive integers. Weights and priority levels are allowed to be variables, provided that these variables also appear in a positive literal in Conj.
The following program, computes the minimum spanning trees of a weighed directed graph.
\\ \textbf{Example 3.9.}
\begin{lstlisting}
root(a).
node(a). node(b). node(c). node(d). node(e).
edge(a,b,4). edge(a,c,3). edge(c,b,2). edge(c,d,3). 
edge(b,e,4). edge(d,e,5).

in_tree(X,Y,C) v out_tree(X,Y) :- edge(X,Y,C), reached(X).
:- root(X), in_tree(_,X,C).
:- in_tree(X,Y,C), in_tree(Z,Y,C), X != Z.

reached(X):- root(X).
reached(Y):- reached(X), in_tree(X,Y,C).
:- node(X), not reached(X).

: in_tree(X,Y,C). [C:1]
\end{lstlisting}
Best model: \texttt{\{reached(a), out\_tree(a,b), in\_tree(a,c,3), reached(b), reached(c), in\_tree(b,e,4), in\_tree(c,b,2), in\_tree(c,d,3), reached(e), reached(d), out\_tree(d,e)\}}
\\Cost ([Weight:Level]): $<[12:1]>$
\\Finally, we show an example where both weights and priorities are specified. This example and some others are taken from the DLV-User Manual \cite{dlvum}. Consider the problem of assigning a given set of employees to two projects. As a minor desideratum, we wish that members of the same group already know each other. Higher level constraints ask each group to be heterogeneous as far as skills are concerned, and require that people married with one another do not work in the same group.
\textbf{Example 3.10.}
\begin{lstlisting}
% This example specify both weights and priorities
employee(a). employee(b). employee(c). employee(d). employee(e).
know(a,b). know(b,c). know(c,d). know(d,e).
same_skill(a,b).
married(c,d).

member(X,p1) v member(X,p2) :- employee(X).
:~ member(X,P), member(Y,P), X != Y, not know(X,Y). [1:1]
:~ member(X,P), member(Y,P), X != Y, married(X,Y). [1:2]
:~ member(X,P), member(Y,P), X != Y, same_skill(X,Y). [1:2] 
\end{lstlisting}
This program has two best models:
\\ \texttt{Best model:}\{member(a,p2), member(b,p1), member(c,p1), member(d,p2), member(e,p2)\}
\\Cost ([Weight:Level]): $<[6:1],[0:2]>$
\\ \\ \texttt{Best model:}\{member(a,p1), member(b,p2), member(c,p2), member(d,p1), member(e,p1)\}
\\Cost ([Weight:Level]): $<[6:1],[0:2]>$


\subsection{External Atoms}
Till now we did not show any property which makes \dlvhex{} different than other ASP solvers. Now we are introducing new property which makes \dlvhex{} very powerful computation tool for any kind of problem in ASP. When introducing \dlvhex{} we introduced also \hex{} programs. \hex{} programs are nonmonotonic logic programs admitting \textit{high-order atoms} as well as \textit{external atoms}, and we extend the well known answer-set semantics to this class of programs. Through external atoms, \hex{} programs can model some important extensions to ASP, and are useful KR tools for expressing various applications \cite{extatoms2}. Advantage of using external atoms is increasing software interoperability. A high-order atom allows to quantify values over predicate names, and to freely exchange predicate symbols with constant symbols, like in the rule \centerline{\\$C(X) \leftarrow \textit{subclassOf(D,C),D(X)}$}
An \textit{external atom} facilitates to determine the truth value of an atom through an external source of computation. For instance, the rule \\ \centerline{ \textit{$reached(X) \leftarrow \&reach[edge,a](X)$}}
\\computes the predicate \textit{reached} taking values from the predicate $\&reach$, which computes via \textit{$\&reach[edge,a](X)$} all the reachable nodes in the graph in the graph \textit{edge} from node \textit{a}, delegating this task to an external computational source (e.g., an external deduction system, an execution library, etc.). From the text above everyone can see why \hex{} programs are so powerful and useful today.  Before going on with examples let us explain syntax of \hex{} programs. 
\subsubsection{\hex{} programs-Syntax}
Let $\textit{C,X, and G}$ be mutually disjoint sets whose elements are called \textit{constant names, variable names,} and \textit{external predicate names,} respectively. Unless explicitly specified, elements from \textit{X} are denoted with first letter in upper case, while elements from \textit{G} are prefixe with '\&'. We note that the constant names serve both as individual and predicate names.

Elements from \textit{C} $\cup$ \textit{X} are called \textit{terms}. A \textit{high-order atom} is a tuple ($Y_0, Y_1,...,Y_n$), where $Y_0, Y_1,...,Y_n$ are terms; $ n \ge 0$ is the \textit{arity} of the atom. Intuiitively, $Y_0$ is the predicate name, and we thus also use the more familiar notation $Y_0(Y_1,...,Y_n)$. The atom is \textit{ordinary}, if $Y_0$ is a constant. For example, \textit{(x,rdf:type,c),node(X), and D(a,b),} are atoms;the first two are ordinary atoms. An \textit{external atom} is of the form \\ \centerline{ \&g[$Y_1,...,Y_n$]($X_1,...,X_m$),} \\where $Y_1,...,Y_n$ and $X_1,...,X_m$ are the two lists of terms(called \textit{input} and \textit{output} lists, respectively), and \&g $\in$ \textit{G} is an external predicate name. We assume that \&g has fixed lengths \textit{in(\&g)} = n and \textit{out(\&g)} = m for input and output lists, respectively. Intuitively, an external atom provides a way for deciding the truth value of an output tuple depending on the extension of a set of input predicates.       
\\To understand concept better we are providing example which show how we can get use of external atoms in ordinary ASP.
\\ \textbf{\\Example X.X.}
\\ \lstinputlisting{introductiontohex.hex}     
Above is \hex{} program  which works with constant input parameters  to external sources. For each system, it concatenates string "hello" and system name using \textbf{concat} external source. At the output we have something like: \textit{sayhello(hellodlvhex), sayhello(helloclasp)}. Last part of the program works with predicate input parameters. It first define two different sets and then computes set1 minus set2 using \textbf{setdiff} external source. External source definition is given below:
\lstinputlisting{extsource.py}
After this short example one can see how system is working and what are the advantages of \dlvhex{} over ordinary ASP solvers.  





\newpage
\section{References}
\begin{thebibliography}{1}
\bibitem{extatoms} Thomas Eiter, Micheal Fink, Thomas Krennwallner, Christoph Redl {\em Conflict-driven ASP Solving with External Sources} 2003   
  
\bibitem{ref} Francesco Calimeri, Wolfgang Faber, Martin Gebser, Giovambattista Ianni, Roland Kaminski, Thomas Krennwallner, Nicola leone, Francesco Ricca, Torsten Schaub {\em ASP-Core-2 Input Language} 2013.

\bibitem{licnc} GNU Lesser General Public License. Free Software Foundation, Inc. https://www.gnu.org/copyleft/lesser.html 

\bibitem{onlinedemo}dlvhex. Vienna University of Technology. http://www.kr.tuwien.ac.at/research/systems/dlvhex/demo.php 

\bibitem{git}Software for HEX-Programs. GitHub. https://github.com/hexhex/ 

\bibitem{sourceforge}DLVHEX solver for HEX-programs-  Browse Files at SourceForge.net. Sourceforge.net. http://sourceforge.net/projects/dlvhex/files/

\bibitem{prebuilt}KBS-ASP systems. Thomas Krenwallner. http://www.kr.tuwien.ac.at/staff/tkren/deb.html

\bibitem{boost}Boost C++ Libraries. Boost.org. http://www.boost.org/

\bibitem{hexhex}dlvhex. GitHub. https://github.com/hexhex/core

\bibitem{script}Web location for script

\bibitem{extatoms2}Thomas Eiter, Giovamattista Ianni, Roman Schindlauer and hans Tompits {\em A Uniform Integration of Higher-Order Reasoning and External Evaluations in Answer-Set Programming} 


\bibitem{pott}Martin Gebser, Roland Kaminski, Benjamin Kaufmann, Marius Lindauer, Max Ostrowski, Javier Romero, Trosten Schaub and Sven Thiele {\em Pottasco User Guide}

\bibitem{dlvum}Robert Bihlmeyer, Wolfgang Faber, Giuseppe Ielpa, Vincezino Lio and Gerald Pfeifer {\em DLV-User Manual} 
      
 
 \end{thebibliography} 



\end{document}


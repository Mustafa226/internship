\documentclass[14pt,a4paper, titlepage]{article}

\usepackage{graphicx}
\usepackage{url}
\usepackage{setspace}
\usepackage{listings}



\begin{document}

\setcounter{page}{3}
\title{HEX-programs solver (DLVHEX)}
\author{Christoph Redl}
\date{\today}
\maketitle

\newcommand{\dlvhex}{{\sc DLVHEX}}
\newcommand{\hex}{{\sc HEX}}



% Abstract part
\begin{abstract}
This document provides a user guide for the Answer Set Programming(ASP) system called \dlvhex{} developed at Vienna University of Technology. ASP is a declarative problem solving paradigm, rooted in Logic Programming and Nonmonotonic Reasoning, which has been gaining increasing attention during the last years. The \dlvhex{} system is a logic-programming reasoner for computing the models of so-called \hex{}-programs, which are an extension of \textbf{answer-set programs} towards integration of \textbf{external computation sources}. This guide, aims at enabling users of this system to interoperate with a broader set of external computation sources since there is no adequate support available for the meta-reasoning in the context of the Semantic Web up to date. Using this guide ASP novices will be able to exploit Answer Set Programming and some of its tools as \dlvhex{}. The guide generally refers to the \textbf{dlvhex2} release. Please make sure that you are using corresponding(or later) versions available.     
\end{abstract}

% Generates table of contents
\tableofcontents

\newpage

\section{Introduction} % Section No.1
The \dlvhex{} system is a logic-programming reasoner for computing the models of so-called \hex{}-programs, which are an extension of \textbf{answer-set programs} towards integration of \textbf{external computation sources}. To enable access to external information, \hex{}-programs extend programs with external atoms, which allow for a bidirectional communication between the logic program and external sources of computation (e.g., description logic reasoners and Web resources). \cite{extatoms} The system is developed motivated by the need to interoperate with a broader set of external computation sources and the observation, that for meta-reasoning in the context of the Semantic Web, no adequate support is available in ASP to date. As a fact of this \hex{}-programs are introduced, that is, higher-order logic programs (which accommodate meta-reasoning through higher-order atoms) with external atoms for software interoperability.

This guide, helps ASP novices to make use of the system with all its features. It provides a reference of the tools' features that ASP might be tempted to exploit. The language of \hex{}-programs is an extension of disjunctive datalog. It largely implements the ASP-Core-2 Standard \cite{ref} and extends it with external atoms. 

In this guide we'll try to explain the fundamentals of using \dlvhex{} so that reader will be able to benefit from them by significantly reducing the time to solution on difficult computational problems. 


\subsection{Download and Installation}
\dlvhex{} is the name of prototype application for computing the models of so-called \hex{}-programs. It is written in C++ programming-language and it is published under GNU Lesser General Public License \cite{licnc}.\bigskip \\For a quick overview, some examples and the possibility to evaluate \hex{}-programs directly in your browser, you can check out the online demo at \cite{onlinedemo}. However the system can also be installed locally. The source code of \dlvhex{}is hosted using git at \cite{git}. Packages (tarballs) of \dlvhex{} can be downloaded from the \cite{sourceforge} project page. The latest release of the software runs on Linux-based systems and (Mac) OS X. In the close time we will have stable release which will work on Windows. For some systems we provide pre-built packages \cite{prebuilt}  for others you may build the software from source. Since building the software from the source is not easy task we will explain all details which are necessary to make system working. You can find last stable release version of the \dlvhex{} at the \cite{sourceforge}. Installation instructions are given in the {\tt INSTALL} and {\tt README} files of the \dlvhex{} and plugin source directories. Changes between versions can be found in the {\tt NEWS} files and in detail in the ChangeLog files.

If you want to build software from the source \dlvhex{} uses the standard configure, make and make install commands from the shell. Download software from the repository to your working directory to the new folder. To complete installation successfully one have to install all dependencies which are required. If you have the most recent Linux distribution almost all packages will be already available. Here we will list some packages required: git, gcc(in version 4.8 or later), g++(in version 4.8 or later), libbz2-dev, python(in version 2.7 or later) and etc. While installing the system one can notice if some package except these is missing and simply install it by using sudo apt-get install command. Also \textbf{libboost} in version 1.55 or later is required. You can find latest boost version at \cite{boost}. Download it to the new foldr and then install it. Before executing configure, make and make install commands one will run bootstrap.sh script from the boost directory to have all dependencies required. Now when all dependencies are satisfied you can simply git clone (--recursive) system from the \cite{hexhex} to get most recent developed version. Note that this version may not be stable since it is still not in release mode. After cloning repository you will execute again bootsrap.sh script and at the end invoke configure, make and make install commands.\bigskip \\We have written script which should install \dlvhex{} automatically on your system. You can find script at \cite{script}. If script is not working for you, you can at least see the commands and adopt them as needed for system which you are using. When installation is completed you can run system from the terminal as:\\ 
\textbf{shell\$ dlvhex2 --strongnegation-enable=true --liberalsafety --pythonplugin=extsource.py program.hex}
where program.hex and extsource.py refer to the program and plugin entered above, respectively    

\subsection{Outline}
In this guide we will introduce fundamentals of using \dlvhex{} system. Benefits of using this guide is that ASP novices will be able to learn faster how to use this system and use it to solve real ASP problems. To this end, Section 2 provides an introductory example which will be used to explain problem instance, encoding and its solution. Third part of this document is focused on input language of the \dlvhex{}. After explaining input language of the system, in Section 4 we introduced three real life problems which can be solved using our system and its features. Scetion 5 is focused on description of External Interfaces which are written in C++ and Python. Some input-related warnings and errors are described into more details in Section 6. And finally in Section 7 we described what is future work that may be considered with the system. \bigskip \\After all these preliminaries, it is time to start our guided tour through \dlvhex{} system.      

\newpage
\section{Quickstart} % Section No.2
\subsection{Problem Instance}
\subsection{Problem Encoding}
\subsection{Problem Solution}
\subsection{Summary}

\newpage
\section{Input Language}% Section No. 3
This section provides an overview of the input language of \dlvhex{}. We will explain all inputs which are accepted by \dlvhex{} and provide some examples so that users will be able to understand concept better. If we know what are the inputs accepted by \dlvhex{} we can use it more efficiently and then we are using all features of the software.  
\subsection{Terms}
Every (non-propositional) logic program includes terms, mainly to specify arguments of atoms. \\Terms may be: integers, constants, strings and variables as well as the '\_' tokens. An integer is represented by means of an arithmetic expression. Constant names begin with lowercase leters and variable names begin with uppercase letters. \\ While a constant or string represent itself, a variable is placeholder for all variable-free terms in the language of a logic program. There is a special feature, which is called anonymous variable. The anonymous variable is denoted by "\_" (the underscore) and is different from a usual variable. Each occurrence of \_ represents a new and unique variable, which does not occur anywhere else in the same rule. The purpose of this feature is to specify that an argument can be ignored or does not matter in the current rule constraint without having to invent new and unique variable names.  It has also external atoms as input but its syntax is explained in the last subsection of the Section 3. Finally there are tuples which are also accepted. Examples for tuples are: the empty tuple () and the tuple (peter, at, X, Y) with four elements.\bigskip%
\\ \textbf{Example 3.1.} 
Simple terms are:
\\ \textit{Constants:} a, 1, a1, 9862, c1
\\ \textit{Variables:} X, Y, Z, V2f
\\ \textit{Atoms:} a, b, deaf, smart
\\ \textit{Predicates:} parent(X,Y), employee(name, salary, ID, location)
       

\subsection{Normal Programs and Integrity constraints}
\dlvhex{} is a declarative (programming) language. This means that programmer does not write a program that solves some problem but instead specifies what the solution should look like, and then it tries to solve the problem and find solution itself. There is wide agreement that both syntax and semantics of the language of \dlvhex{} are very simple and intuitive.\\ Each normal logic program is constructed using \textbf{facts, rules and integrity constraints}. 




\begin{quote} 
\centering 
\textbf{Fact:} $ A_0. $ 
\\ \textbf{Rule:} $ A_0  :-  L_1,......,L_n.$
\\ \textbf{Constraint:} $  :-  L_1,.....,L_n.$
\end{quote}
The first line is called a \textit{fact}. It is always true. More common name that we will use for it is \textit{atom}.The sign $":-"$ is meant to be an arrow to the left, the logic programming version of the implication. 
The second line is called a rule. The left side of the rule is called its \textit{head}, and right side is called \textit{body}.
We say that literal \textit{L} is positive if it is an atom , and negative otherwise. While the head atom $A_0$ of the fact must unconditionally be true, the intuitive reading of a rule corresponds to an implication: if all positive literals in the rule's body are true and negative literals are satisfied, then $A_0$ must be true. On the other hand, an integrity constraint is a rule that filters solution candidates, meaning that the literals in its body must not jointly be satisfied. A result of \dlvhex{} computation is called a \textit{model}. The meaning of this is clear: it is a consistent explanation(model) of the world, as far as it system can derive it. If \dlvhex{} cannot find solution then there is no model for the given problem. \\ \textbf{Example 3.1.} \medskip \\Consider the following logic program:\lstinputlisting{example_3.1.hex} The first line here represents an atom and it is always true. The second line is a rule and it goes as "If joke is true, laugh must also be true". Also we can read this as "from joke follows laugh". Model of above program is $\{joke, laugh\}$ since they are the atoms which are true in the program. To explain concept of \textbf{integrity constraints} we will consider following example:\medskip \\ \textbf{Example 3.2.}
\lstinputlisting{example_3.2.hex}This program explains basic syntax and logic of the program very well. In the first three lines one can see node declarations with variables X and Y. We concluded that X and Y are variables since they begin with uppercase letter. It says that: "If edge(X,Y) is true then node(X) is also true". Next line follows same logic just with different variable name. In the \textit{guessing part} \dlvhex{} will list all possible models for the node(X). Each node may be coloured with either red, green or black. We did not see construction as in checking part before. It is called as \textbf{integrity constraint.} Integrity constraints in our framework specify conditions which must not become true in any model. In other words, constraints are formulations of possible inconsistencies. This mechanism is very useful in connection with disjunctive rules. The disjunctive rules serve as generators for different models and the constraints are used to select only the desired ones. Integrity constraint for this particular case will delete all those atoms from the model which does not satisfy our requirement(that there may be no edge between two nodes of equal color).
\subsection{Classical Negation}
\dlvhex{} supports two kinds of negation. Here we will emphasize difference between explicitly expressing falseness of an atom and having it done by \textbf{Complete World Assumption}. The connective \textit{not} expresses default negation, i.e. a literal \textit{not A} is assumed to hold unless atom A is derived to be true. In contrast, the classical (or strong) negation of an atom holds only if it can be derived. In other words if there is no evidence that an atom is true, it is considered to be false. Classical negation, indicated by symbol '-', is permitted in from of an atoms. The semantic relationship between A and -A is simply that they must not jointly hold. 
\\ \textbf{Example 3.3.}
\\ Imagine a simple situation, in which and agent has to cross a railroad. The agent should cross it if there is no train approaching. With this description, one might specify the following program:
\begin{lstlisting}
 cross_railroad :- not train_approaches.
\end{lstlisting}
The following program has the model \textit{cross} because $train\_approaches$ is assumed to be false(as it being true is not stated anywhere). This kind of negation is called negation as failure.\\The next program uses so-called true or classical negation. Since \textit{$-train\_approaches$} is not known to be true, the following program has only an empty model.
\begin{lstlisting}
 cross_railroad :- -train_approaches.
\end{lstlisting}
The difference between the two kinds of negation is quite important: In the first example, we cross the railroad track if we have no information on any trains approaching, which is quite dangerous, while in the second example, we only cross if we know for sure that no train comes. It is important to note that classical negation is stronger than negation as finite failure. If something is true via true negation, it is always also true if negated by negation as failure.
\subsection{Disjunction}
Disjunctive logic programs permit connective 'v' between atoms in rule heads.\\ \textbf{Fact:} $A_0$v ...v$A_m$
\\ \textbf{Rule:} $A_0$v...v$A_m :- L_1,...,L_n. $
\\ A disjunctive head holds if at least one of its atomes is true. In a simple disjunctive program \texttt{a v b.} we have two answer sets. One containing a and another containing b, while both atoms don't jointly belong to an answer set. Let us analyze explain concept on the example:
\\ \textbf{Example 4.4.}
\begin{lstlisting}
left_arm_broken v right_arm_broken.
can_write :- left_arm_broken.
be_angry :- can_write
\end{lstlisting}
Suppose you have met a friend recently and you know that he had one of his arms broken, but you do not know which one. Now you did not receive a greeting card for your birthday and wonder if you should be angry on him or he just could not write because his right hand is broken. In example like this \dlvhex{} will generate two possible explanations. The first rule is called a disjunctive rule; The v is read as "or" and the whole rule is read as "For sure, either the left or the right arm is broken." Without being sure wich arm is broken \dlvhex{} will evaluate the program and produce two models. The rsulting models are \textit{$\{left\_arm\_broken, can\_write, be\_angry$\}} and \textit{$\{right\_arm\_broken$\}}  
In general, the use of disjunction may increase computational complexity since it evaluates more possible models.        
\subsection{Built-in Arithmetic Functions}
Beside 
\subsection{Built-in Comparison Predicates}

\subsection{Conditions and Conditional Literals}

\subsection{Aggregates}

\subsection{Optimization}

\subsection{External Atoms}
Till now we did not show any property which makes \dlvhex{} different than other ASP solvers. Now we are introducing new property which makes \dlvhex{} very powerful computation tool for any kind of problem in ASP. When introducing \dlvhex{} we introduced also \hex{} programs. \hex{} programs are nonmonotonic logic programs admitting \textit{high-order atoms} as well as \textit{external atoms}, and we extend the well known answer-set semantics to this class of programs. Through external atoms, \hex{} programs can model some important extensions to ASP, and are useful KR tools for expressing various applications \cite{extatoms}. 




\section{References}
\begin{thebibliography}{1}
\bibitem{extatoms} Thomas Eiter, Micheal Fink, Thomas Krennwallner, Christoph Redl {\em Conflict-driven ASP Solving with External Sources} 2003   
  
\bibitem{ref} Francesco Calimeri, Wolfgang Faber, Martin Gebser, Giovambattista Ianni, Roland Kaminski, Thomas Krennwallner, Nicola leone, Francesco Ricca, Torsten Schaub {\em ASP-Core-2 Input Language} 2013.

\bibitem{licnc} GNU Lesser General Public License. Free Software Foundation, Inc. https://www.gnu.org/copyleft/lesser.html 

\bibitem{onlinedemo}dlvhex. Vienna University of Technology. http://www.kr.tuwien.ac.at/research/systems/dlvhex/demo.php 

\bibitem{git}Software for HEX-Programs. GitHub. https://github.com/hexhex/ 

\bibitem{sourceforge}DLVHEX solver for HEX-programs-  Browse Files at SourceForge.net. Sourceforge.net. http://sourceforge.net/projects/dlvhex/files/

\bibitem{prebuilt}KBS-ASP systems. Thomas Krenwallner. http://www.kr.tuwien.ac.at/staff/tkren/deb.html

\bibitem{boost}Boost C++ Libraries. Boost.org. http://www.boost.org/

\bibitem{hexhex}dlvhex. GitHub. https://github.com/hexhex/core

\bibitem{script}Web location for script

\bibitem{extatoms}Thomas Eiter, Giovamattista Ianni, Roman Schindlauer and hans Tompits {\em A Uniform Integration of Higher-Order Reasoning and External Evaluations in Answer-Set Programmin} 
      
 
 \end{thebibliography} 



\end{document}


\documentclass[14pt,a4paper, titlepage]{article}

\usepackage{graphicx}
\usepackage{url}
\usepackage{setspace}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{amsmath}

\begin{document}
\setcounter{page}{3}
\newcommand{\dlvhex}{{\sc dlvhex}}
\newcommand{\hex}{{\sc hex}}
\setcounter{secnumdepth}{4} % how many sectioning levels to assign numbers to
\setcounter{tocdepth}{4}    % how many sectioning levels to show in ToC

\begin{titlepage}
    \centering
    \vfill
    \includegraphics[width=15cm,height=6cm]{biglogo_whitebg}
    \vfill
    {\bfseries\Large
        User Guide
        \vskip4cm
        Christoph Redl\vskip1cm Mustafa Mehuljic
    }    
    
\end{titlepage}

% Abstract part
\begin{abstract}
This document provides a user guide for the Answer Set Programming(ASP) system called \dlvhex{} developed at Vienna University of Technology. ASP is a declarative problem solving paradigm, rooted in Logic Programming and Nonmonotonic Reasoning, which has been gaining increasing attention during the last years. The \dlvhex{} system is a logic-programming reasoner for computing the models of so-called \hex{}-programs, which are an extension of \textbf{answer-set programs} towards integration of \textbf{external computation sources}. This guide aims at enabling users of this system to interoperate with a broader set of external computation sources. The guide refers to release 2.4.     
\end{abstract}

% Generates table of contents
\tableofcontents

\newpage

\section{Introduction} % Section No.1
The \dlvhex{} system is a logic-programming reasoner for computing the models of so-called \hex{}-programs, which are an extension of \textbf{answer-set programs} towards integration of \textbf{external computation sources}. To enable access to external information, \hex{}-programs extend programs with external atoms, which allow for a bidirectional communication between the logic program and external sources of computation (e.g., description logic reasoners and Web resources)\cite{extatoms}. The system is developed motivated by the need to interoperate with a broader set of external computation sources and the observation, that for meta-reasoning in the context of the Semantic Web, no adequate support is available in ASP to date. To overcome this,\hex{}-programs have been introduced, which support higher-order logic programs (which accommodate meta-reasoning through higher-order atoms) with external atoms for software interoperability.

This guide helps ASP novices to make use of the system with all its features. It provides a reference of the features of the tool that ASP might be tempted to exploit. The language of \hex{}-programs is an extension of disjunctive datalog. It largely implements the ASP-Core-2 Standard \cite{ref} and extends it with external atoms. 

In this guide we try explain the fundamentals of using \dlvhex{} to make that reader benefit from them by significantly reducing the time to solve difficult computational problems. 


\subsection{Download and Installation}
\dlvhex{} is written in C++ programming-language and it is published under GNU Lesser General Public License \cite{licnc}. In this section we provide overview of the download and installation process. For a quick overview, some examples and the possibility to evaluate \hex{}-programs directly in the browser, the online demo at \cite{onlinedemo} is provided. However the system can also be installed locally. 
\subsubsection{Building from source}
There are two possibilities to install \dlvhex{} system from source. One possibilities is to install latest stable release of the system or to install latest development version which may not be stable.  
\paragraph{Latest release version (tarball)}
Packages (tarballs) of \dlvhex{} can be downloaded from the project page\cite{sourceforge}. The latest release of the software runs on Linux-based systems,Mac OS X and Microsoft Windows. The latest stable release version of the \dlvhex{} can be found at \url{http://sourceforge.net/projects/dlvhex/files/}. Installation instructions are given in the {\tt INSTALL} and {\tt README} files of the \dlvhex{} and plugin source directories. Changes between versions can be found in the {\tt NEWS} files and in detail in the {\tt ChangeLog} file.
\\ After downloading latest release version, by executing this command (working directory should be one where \dlvhex{} is downloaded) \\ \\export PYTHON\_BIN=python2.7 \&\& cd core \&\& ./bootstrap.sh \&\& ./configure --enable-python \$dlvhexoptions \&\& make -j4 \&\& make install \\ \\  \dlvhex{} will be successfully installed on your system. 
   
\paragraph{Development version (git clone)}
The source code of \dlvhex{} is hosted on github at \url{https://github.com/hexhex/}. If you want to build software from the source \dlvhex{} uses the standard \\ \centerline{./configure, make and make install} commands from the shell once all dependencies are resolved. The system requires the following packages: git, gcc (version 4.8 or later), g++ (version 4.8 or later), libbz2-dev, Python (version 2.7 or later), bison, scons, cmake, automake, autoconf, libstdc++ (version 4.8 or later), libcurl4-openssl-dev and libool. While installing the system one can notice if some packages except these is missing and simply install it by using \\ \centerline{sudo apt-get install} command. Also Boost Library (version 1
.55 or later) is required. Latest Boost Library version is available at \url{http://www.boost.org/}. After downloading it to the new folder the following steps should be followed in order to properly install Boost Library. Downloaded file should be moved to the folder where Boost Library will be installed. Extract it there and execute following command:\\ \\sudo ./bootstrap.sh $\&\&$ $./b2$ --python-enable --layout=tagged --build-type=complete\\ --threading=multi --prefix=\$ boostdir install -j4 \\ \\Now when all dependencies are satisfied we can simply git clone system from the \url{https://github.com/hexhex/core --recursive} to get most recent developed version. Shell command to do this
\\ \\ \centerline{git clone https://github.com/hexhex/core --recursive} 
\\ \\After downloading latest release version, by executing this command (working directory should be one where \dlvhex{} is downloaded) \\ \\export PYTHON\_BIN=python2.7 \&\& cd core \&\& ./bootstrap.sh \&\& ./configure --enable-python \$dlvhexoptions \&\& make -j4 \&\& make install \\ \\  \dlvhex{} will be successfully installed on your system. Note that this version may not be stable since it is still not in release mode.\\ \\We provide a script which should install \dlvhex{} automatically on your system. You can find script at \url{https://github.com/hexhex/core/blob/master/scripts/setupdlvhex.sh}. \\ \\Once installation is completed,the system can be used from the terminal as follows:\\ 
\centerline{\textbf{shell\$ dlvhex2 program.hex}} where program.hex refers to the input program. Various additional options are available and explained in following sections.    

\subsubsection{Pre-built binaries}
We provide pre-built binaries of \dlvhex{} for some systems. For details see our website \url{http://www.kr.tuwien.ac.at/research/systems/dlvhex/index.html}. 


\subsection{Outline}
This guide is organized as follows: Section 2 provides an introductory example which will be used to explain problem instance, encoding and its solution. Section 3 is focused on input language of the \dlvhex{}. In Section 4 we introduced three real life problems which can be solved using our system. Section 5 is focused on description of external interfaces which are written in C++ and Python. Input-related warnings and errors are described into more details in Section 6. And finally in Section 7 we describe possible future work that may be considered.

\section{Quickstart} % Section No.2



\subsection{Problem Instance}
\subsection{Problem Encoding}
\subsection{Problem Solution}
\subsection{Summary}

\newpage
\section{Input Language}% Section No. 3
This section provides an overview of the input language of \dlvhex{}. We will explain all inputs which are accepted by \dlvhex{} and provide some examples so that users will be able to understand concept better. If we know what are the inputs accepted by \dlvhex{} we can use it more efficiently and then we are using all features of the software.  
\subsection{Terms}
Every (non-propositional) logic program includes terms, mainly to specify arguments of atoms. \\Terms may be: integers, constants, strings and variables as well as the '\_' tokens. An integer is represented by means of an arithmetic expression. Constant names begin with lowercase leters and variable names begin with uppercase letters. \\ While a constant or string represent itself, a variable is placeholder for all variable-free terms in the language of a logic program. There is a special feature, which is called anonymous variable. The anonymous variable is denoted by "\_" (the underscore) and is different from a usual variable. Each occurrence of \_ represents a new and unique variable, which does not occur anywhere else in the same rule. The purpose of this feature is to specify that an argument can be ignored or does not matter in the current rule constraint without having to invent new and unique variable names.  It has also external atoms as input but its syntax is explained in the last subsection of the Section 3. Finally there are tuples which are also accepted. Examples for tuples are: the empty tuple () and the tuple (peter, at, X, Y) with four elements.\bigskip%
\\ \textbf{Example 3.1.} 
Simple terms are:
\\ \textit{Constants:} a, 1, a1, 9862, c1
\\ \textit{Variables:} X, Y, Z, V2f
\\ \textit{Atoms:} a, b, deaf, smart
\\ \textit{Predicates:} parent(X,Y), employee(name, salary, ID, location)
       

\subsection{Normal Programs and Integrity constraints}
\dlvhex{} is a declarative (programming) language. This means that programmer does not write a program that solves some problem but instead specifies what the solution should look like, and then it tries to solve the problem and find solution itself. There is wide agreement that both syntax and semantics of the language of \dlvhex{} are very simple and intuitive.\\ Each normal logic program is constructed using \textbf{facts, rules and integrity constraints}. 




\begin{quote} 
\centering 
\textbf{Fact:} $ A_0. $ 
\\ \textbf{Rule:} $ A_0  :-  L_1,......,L_n.$
\\ \textbf{Constraint:} $  :-  L_1,.....,L_n.$
\end{quote}
The first line is called a \textit{fact}. It is always true. More common name that we will use for it is \textit{atom}.The sign $":-"$ is meant to be an arrow to the left, the logic programming version of the implication. 
The second line is called a rule. The left side of the rule is called its \textit{head}, and right side is called \textit{body}.
We say that literal \textit{L} is positive if it is an atom , and negative otherwise. While the head atom $A_0$ of the fact must unconditionally be true, the intuitive reading of a rule corresponds to an implication: if all positive literals in the rule's body are true and negative literals are satisfied, then $A_0$ must be true. On the other hand, an integrity constraint is a rule that filters solution candidates, meaning that the literals in its body must not jointly be satisfied. A result of \dlvhex{} computation is called a \textit{model}. The meaning of this is clear: it is a consistent explanation(model) of the world, as far as it system can derive it. If \dlvhex{} cannot find solution then there is no model for the given problem. \\ \textbf{Example 3.1.} \medskip \\Consider the following logic program:\lstinputlisting{example_3.1.hex} The first line here represents an atom and it is always true. The second line is a rule and it goes as "If joke is true, laugh must also be true". Also we can read this as "from joke follows laugh". Model of above program is $\{joke, laugh\}$ since they are the atoms which are true in the program. To explain concept of \textbf{integrity constraints} we will consider following example:\medskip \\ \textbf{Example 3.2.}
\lstinputlisting{example_3.2.hex}This program explains basic syntax and logic of the program very well. In the first three lines one can see node declarations with variables X and Y. We concluded that X and Y are variables since they begin with uppercase letter. It says that: "If edge(X,Y) is true then node(X) is also true". Next line follows same logic just with different variable name. In the \textit{guessing part} \dlvhex{} will list all possible models for the node(X). Each node may be coloured with either red, green or black. We did not see construction as in checking part before. It is called as \textbf{integrity constraint.} Integrity constraints in our framework specify conditions which must not become true in any model. In other words, constraints are formulations of possible inconsistencies. This mechanism is very useful in connection with disjunctive rules. The disjunctive rules serve as generators for different models and the constraints are used to select only the desired ones. Integrity constraint for this particular case will delete all those atoms from the model which does not satisfy our requirement(that there may be no edge between two nodes of equal color).
\subsection{Classical Negation}
\dlvhex{} supports two kinds of negation. Here we will emphasize difference between explicitly expressing falseness of an atom and having it done by \textbf{Complete World Assumption}. The connective \textit{not} expresses default negation, i.e. a literal \textit{not A} is assumed to hold unless atom A is derived to be true. In contrast, the classical (or strong) negation of an atom holds only if it can be derived. In other words if there is no evidence that an atom is true, it is considered to be false. Classical negation, indicated by symbol '-', is permitted in from of an atoms. The semantic relationship between A and -A is simply that they must not jointly hold. 
\\ \textbf{Example 3.3.}
\\ Imagine a simple situation, in which and agent has to cross a railroad. The agent should cross it if there is no train approaching. With this description, one might specify the following program:
\begin{lstlisting}
 cross_railroad :- not train_approaches.
\end{lstlisting}
The following program has the model \textit{cross} because $train\_approaches$ is assumed to be false(as it being true is not stated anywhere). This kind of negation is called negation as failure.\\The next program uses so-called true or classical negation. Since \textit{$-train\_approaches$} is not known to be true, the following program has only an empty model.
\begin{lstlisting}
 cross_railroad :- -train_approaches.
\end{lstlisting}
The difference between the two kinds of negation is quite important: In the first example, we cross the railroad track if we have no information on any trains approaching, which is quite dangerous, while in the second example, we only cross if we know for sure that no train comes. It is important to note that classical negation is stronger than negation as finite failure. If something is true via true negation, it is always also true if negated by negation as failure.
\subsection{Disjunction}
Disjunctive logic programs permit connective 'v' between atoms in rule heads.\\ \textbf{Fact:} $A_0$v ...v$A_m$
\\ \textbf{Rule:} $A_0$v...v$A_m :- L_1,...,L_n. $
\\ A disjunctive head holds if at least one of its atomes is true. In a simple disjunctive program \texttt{a v b.} we have two answer sets. One containing a and another containing b, while both atoms don't jointly belong to an answer set. Let us analyze explain concept on the example:
\\ \textbf{Example 3.4.}
\begin{lstlisting}
left_arm_broken v right_arm_broken.
can_write :- left_arm_broken.
be_angry :- can_write
\end{lstlisting}
Suppose you have met a friend recently and you know that he had one of his arms broken, but you do not know which one. Now you did not receive a greeting card for your birthday and wonder if you should be angry on him or he just could not write because his right hand is broken. In example like this \dlvhex{} will generate two possible explanations. The first rule is called a disjunctive rule; The v is read as "or" and the whole rule is read as "For sure, either the left or the right arm is broken." Without being sure wich arm is broken \dlvhex{} will evaluate the program and produce two models. The rsulting models are \textit{$\{left\_arm\_broken, can\_write, be\_angry$\}} and \textit{$\{right\_arm\_broken$\}}  
In general, the use of disjunction may increase computational complexity since it evaluates more possible models.        
\subsection{Built-in Arithmetic Functions}
Beside integers (constant arithmetic functions), written as sequence of digits 0...9 possibly preceded by '-', \dlvhex{} supports other types of arithmetic functions that can be evaluated. We are using following syntax for those functions: +(addition), -(subtraction), *(multiplication), /(integer division). Each of these functions usage is given in the example bellow:
\\ \textbf{Example 3.5.}
\begin{lstlisting}
% This example demonstrates usage of built-in arithmetic functions
a(6).
b(2).

c(X,Y,XX) :- a(X), b(Y),+(X, Y, XX).
d(X,Y,XX) :- a(X), b(Y),-(X, Y, XX).
e(X,Y,XX) :- a(X), b(Y),*(X, Y, XX).
f(X,Y,XX) :- a(X), b(Y),/(X, Y, XX).
\end{lstlisting}
Answer set for the example above is: \\$\{a(6),b(2),e(6,2,12),f(6,2,3),c(6,2,8),d(6,2,4)\}$
     
\subsection{Built-in Comparison Predicates}
\dlvhex{} feature a total order among variable-free terms. The built-in predicates to compare terms are ==(equal), !=(not equal), $<$(less than), $\leq$(less than or equal), $>$(greater than) and $\geq$(greater than or equal). All kinds of constants (symbols and integers) may be compared against each other freely. If two integers are compared, the semantics are as expected. All other comparisons are just guaranteed to impose a fixed ordering over all constants. The application of comparison literals to integers is illustrated by the following example.
\\ \textbf{Example 3.6.}
\begin{lstlisting}
% This example demonstrates usage of built-in comparison predicates
a(1).
a(2).
b(1).

c(X,Y) :- a(X), b(Y), X <> Y.
d(X,Y) :- a(X), b(Y), X != Y.
e(X,Y) :- a(X), b(Y), X < Y.
f(X,Y) :- a(X), b(Y), X > Y.
g(X,Y) :- a(X), b(Y), X <= Y.
h(X,Y) :- a(X), b(Y), X >= Y.
i(X,Y) :- a(X), b(Y), Y == 1.
\end{lstlisting}
Answer set for the example above is:\\$\{a(1),a(2),b(1),i(1,1),i(2,1),c(2,1),d(2,1),f(2,1),g(1,1),h(1,1),h(2,1)\}$
\subsection{Conditions and Conditional Literals}
A \textit{conditional literal} is of the form \\ \centerline{$L_0:L_1,...,L_n$} where every \textit{$L_j$ for 0$\leq$j$\leq$n} is a literal, $L_1,...,L_n$ is called \textit{condition}, and ":" resembles mathematical set notation. Whenever \textit{n = 0}, we het a regular literal and denote it usual by $L_0$.

For example, the rule \\$a :- b : c. $ \\yields \textit{a} whenever either \textit{c} is false(and thus no matter whether \textit{b} holds or not) or both b and c are true \cite{pott}. \\Together  with variables, conditions allow for specifying collections of expressions within a single rule or aggregate. This is particularly useful for encoding conjunctions(or disjunctions) over arbitrarily many ground atoms as well as for the compact representation of aggregates. 
\\ \textbf{Example 3.7.}
\begin{lstlisting}
% This example demonstrates usage of conditions in rule's head and body

person(jane). person(john).
day(mon). day(tue). day(wed). day(thu). day(fri).
available(jane) :- not on(fri).
available(john) :- not on(mon), not on(wed).
meet :- available(X) : person(X).
on(X) : day(X) :- meet.
\end{lstlisting}  
We have used conditions in last two lines of the code. The conjunction in the body of line 5 is obtained by replacing X in \textit{available(X)} with all ground terms \textit{t} such that \textit{person(t)} holds, namely, with t=jane and t=john. The condition for the last line is contained in the head of rule. It turns into disjunction over all ground instances of \textit{on(X)} such that X is substituted by terms t for which \textit{day(t)} holds. Any variable occurring within a condition does not count as a positive occurrence outside the condition in the sense of safety. variables occurring in atoms not subject to any conditions are global. Each variable within an atom in front of a condition mist be global or have a positive occurrence on the right hand-side of the condition. During grounding, the instantiation of global variables take precedence over non-global ones, that is, the former are instantiated before the latter.As a consequence, variables that occur globally are substituted by terms before a condition is further evaluated \cite{pott}.    
\subsection{Aggregates}
Aggregates allow to express properties over set of elements. DLV and \hex{} programs with aggregates often allow clean and concise problem encodings by minimizing the use of auxiliary predicates and recursive programs, and help the programmers to depict problems in a more natural way. For instance, we may state that the sum of a semester's course credits must be at least 20, or that the sum of shopping items must not exceed 30 Euros. We can say that an aggregate is a function on a set of tuples that are normally subject to conditions. By comparing an aggregated value with given values, we can extract a truth value from an aggregate's evaluation, thus obtaining an aggregate atom 
They can occur in the bodies of rule and constraints, possibly negated using negation-as-failure. \\ \textbf{Body Aggregates} The form of an \textit{aggregate atom} occuring in a rule body is as follows:\\ \centerline{$s_1 \prec_1 \alpha \{ t_1:L_1;...;t_n:L_n\} \prec_2 s_2$} 
\\ Here, all \textit{$t_i$} and \textit{$L_i$}, forming \textit{aggregate elements}, are non-empty tuples of terms and literals, respectively. $\alpha$ is the name of some function that is applied to the term tupples \textit{$t_i$} that remain after evaluating the conditions expressed by $L_i$. Finally,  the result of applying $\alpha$ is compared by means of the comparison predicates $\prec_1 or \prec_2$ to the terms $s_1$ and $s_2$ respectively. \#count, \#sum, \#times, \#min, and \#max are called aggregate functions, and \dlvhex{} currently supports exactly these five. An aggregate function is applied over a set and returns a numeric value. Unlike other aggregates, count aggregate does not require weights.    
\\ \textbf{Example 3.8.}
\begin{lstlisting}
% This example demonstrates usage of aggregates:

#maxint=6.
c(2).
c(3).
c(6).

a(f,g,k).
a(u,h,k).
b(e,g,s).
b(e,h,x).
b(e,h,q).
on v off.

b(e,h,r) :- on.
p(W) :- #min{S : c(S)} = W, #int(W).
ok(C) :- #count{X,Y : a(X,Z,k),b(e,Z,Y)} = 3, p(C).
\end{lstlisting}
Answer sets for this example are:
\\ 1. {c(2),c(3),c(6),a(f,g,k),a(u,h,k),b(e,g,s),b(e,h,x),b(e,h,q),off,p(2),ok(2)}
\\ 2. {c(2),c(3),c(6),a(f,g,k),a(u,h,k),b(e,g,s),b(e,h,x),b(e,h,q),on,b(e,h,r),p(2)}
\\After this example we can show all aggregate functions currently supported in \dlvhex{} in one example:
\\ \textbf{Example 3.9.}
\begin{lstlisting}
% This example demonstrates usage of aggregate functions:
% Each employee is is represented by a fact of the form emp(ID,NAME,SALARY)

emp(1,goofie,1250).
emp(2,willy,700).
emp(3,woody,750).
emp(4,jerry,900).
emp(5,tom,1050).
\end{lstlisting}
Aggregate function \textbf{\#count} returns the cardinality of the symbolic set to which it is applied. We want to count how many employees of the company earn more than 1000. 
\begin{lstlisting}
over1000(I,S) :- emp(I,N,S), S > 1000.
over1000nr(X) :- #count{I : over1000(I,W)} = X, #int(X).
\end{lstlisting}
Intuitively the symbolic set appearing in the aggregate predicate consists of two ground predicates: \\ \centerline{$\{<1,over1000(1,1250)>,<5,over1000(5,1050)>\}$}
\\which are both true w.r.t. the unique model of the whole program, hence \\ \centerline{$ \#count\{over1000(1,1250),over1000(5,1050)\}$} \\returns 2 as output of aggregate function and outputs:\\ {emp(1,goofie,1250),emp(2,willy,700),emp(3,woody,750),emp(4,jerry,900),\\emp(5,tom,1050),over1000(1,1250),over1000(5,1050),over1000nr(2)}
as a result of the program.
\bigskip \\Aggregate function \textbf{\#sum} returns the sum of the first local variable to be aggregated over in the symbolic set. Suppose we want to know how much Cartoon Co. spends on salaries.
\begin{lstlisting}
salaryTotal(X) :- #sum{S,I : emp(I,N,S)} = X.
\end{lstlisting}
The symbolic set here consists of 5 elements, namely all of the facts stored in the database of the employees. The aggregate function applied to the given set returns the sum of the salaries of all the employees, the output thus is:
{salaryTotal(4650)}. \textbf{\#times} is similar to \#sum, but computes the product of the first local variable to be aggregated over in the symbolic set. When applied over the empty set, \#times returns 1.
\bigskip \\The aggregate function \textbf{\#min} returns the minimum value of the first local variable to be aggregated over in the symbolic set. The following simple program then returns the lowest income among all employees.
\begin{lstlisting}
lowest(X) :- #min{S : emp(I,N,S)} = X.
\end{lstlisting}
The aggregate function applied to the given set returns the minimum salary among of all the employees, the output thus is:
{lowest(700)}
\bigskip \\ The aggregate function \textbf{\#max} returns the maximum value of the first local variable to be aggregated over in the symbolic set. The following program computes the maximum income earned in the company
\begin{lstlisting}
highest(X) :- #max{S : emp(I,N,S)} = X.
\end{lstlisting}
and it outputs $\{highest(1250)\}$ as a highest income in the company.

\subsection{Optimization}
Introducing \textbf{weak constraints} into \hex programs allows us to formulate several optimization problems in an easy and natural way. These weak constraints are adopted from \textit{dlv}. While standard constraints (integrity constraints, strong constraints) always have to be satisfied, weak constraints should be satisfied if it is possible, but their violation does not "kill" the models.//The answer sets of a program P with a set W of weak constraints are those answer sets of P which minimize the number of violated weak constraints. They are called Best Models of (P,W). Note that a program may have several best models (violating the same number of weak constraints).\\ Weak constraints can be weighted according to their importance (the higher the weight, the more important the constraint). In the presence of weights, best models minimize the sum of the weights of the violated weak constraints. Weak constraints can also be prioritized. Under prioritization, the semantics minimizes the violation of the constraints of the highest priority level first; then the lower priority levels are considered one after the other in descending order. Syntactically, weak constraints are specified as follows. \\ \centerline{$:~ Conj. [Weight:Level]$} \\ where Conj is a conjunction of (possibly negated) literals, and both Weight and Level are positive integers. Weights and priority levels are allowed to be variables, provided that these variables also appear in a positive literal in Conj. The user can omit the weight or the priority or both, but all weak constraints must have the same syntactic form (i.e., the user is free to specify only weights or only priorities, or both, but all constraints of the program must have the same syntactic form)\cite{dlvum}.
The following program, computes the minimum spanning trees of a weighed directed graph.
\\ \textbf{Example 3.9.}
\begin{lstlisting}
root(a).
node(a). node(b). node(c). node(d). node(e).
edge(a,b,4). edge(a,c,3). edge(c,b,2). edge(c,d,3). edge(b,e,4). edge(d,e,5).

in_tree(X,Y,C) v out_tree(X,Y) :- edge(X,Y,C), reached(X).
:- root(X), in_tree(_,X,C).
:- in_tree(X,Y,C), in_tree(Z,Y,C), X != Z.

reached(X):- root(X).
reached(Y):- reached(X), in_tree(X,Y,C).
:- node(X), not reached(X).

:~ in_tree(X,Y,C). [C:1]
\end{lstlisting}
Best model: {reached(a), out\_tree(a,b), in\_tree(a,c,3), reached(b), reached(c), in\_tree(b,e,4), in\_tree(c,b,2), in\_tree(c,d,3), reached(e), reached(d), out\_tree(d,e)}
\\Cost ([Weight:Level]): $<[12:1]>$
\\Finally, we show an example where both weights and priorities are specified. Example is taken from the DLV-User Manual\cite{dlvum}. Consider the problem of assigning a given set of employees to two projects. As a minor desideratum, we wish that members of the same group already know each other. Higher level constraints ask each group to be heterogeneous as far as skills are concerned, and require that people married with one another do not work in the same group.
\newpage 
\textbf{Example 3.10.}
\begin{lstlisting}
% This example specify both weights and priorities
employee(a). employee(b). employee(c). employee(d). employee(e).
know(a,b). know(b,c). know(c,d). know(d,e).
same_skill(a,b).
married(c,d).

member(X,p1) v member(X,p2) :- employee(X).
:~ member(X,P), member(Y,P), X != Y, not know(X,Y). [1:1]
:~ member(X,P), member(Y,P), X != Y, married(X,Y). [1:2]
:~ member(X,P), member(Y,P), X != Y, same_skill(X,Y). [1:2] 
\end{lstlisting}
This program has two best models:
\\ \textbf{Best model: }{member(a,p2), member(b,p1), member(c,p1), member(d,p2), member(e,p2)}
\\Cost ([Weight:Level]): $<[6:1],[0:2]>$
\\ \textbf{Best model: }{member(a,p1), member(b,p2), member(c,p2), member(d,p1), member(e,p1)}
\\Cost ([Weight:Level]): $<[6:1],[0:2]>$


\subsection{External Atoms}
Till now we did not show any property which makes \dlvhex{} different than other ASP solvers. Now we are introducing new property which makes \dlvhex{} very powerful computation tool for any kind of problem in ASP. When introducing \dlvhex{} we introduced also \hex{} programs. \hex{} programs are nonmonotonic logic programs admitting \textit{high-order atoms} as well as \textit{external atoms}, and we extend the well known answer-set semantics to this class of programs. Through external atoms, \hex{} programs can model some important extensions to ASP, and are useful KR tools for expressing various applications \cite{extatoms2}. Advantage of using external atoms is increasing software interoperability. A high-order atom allows to quantify values over predicate names, and to freely exchange predicate symbols with constant symbols, like in the rule \centerline{\\$C(X) \leftarrow \textit{subclassOf(D,C),D(X)}$}
An \textit{external atom} facilitates to determine the truth value of an atom through an external source of computation. For instance, the rule \\ \centerline{ \textit{$reached(X) \leftarrow \&reach[edge,a](X)$}}
\\computes the predicate \textit{reached} taking values from the predicate $\&reach$, which computes via \textit{$\&reach[edge,a](X)$} all the reachable nodes in the graph in the graph \textit{edge} from node \textit{a}, delegating this task to an external computational source (e.g., an external deduction system, an execution library, etc.). From the text above everyone can see why \hex{} programs are so powerful and useful today.  Before going on with examples let us explain syntax of \hex{} programs. 
\subsubsection{\hex{} programs-Syntax}
Let $\textit{C,X, and G}$ be mutually disjoint sets whose elements are called \textit{constant names, variable names,} and \textit{external predicate names,} respectively. Unless explicitly specified, elements from \textit{X} are denoted with first letter in upper case, while elements from \textit{G} are prefixe with '\&'. We note that the constant names serve both as individual and predicate names.

Elements from \textit{C} $\cup$ \textit{X} are called \textit{terms}. A \textit{high-order atom} is a tuple ($Y_0, Y_1,...,Y_n$), where $Y_0, Y_1,...,Y_n$ are terms; $ n \ge 0$ is the \textit{arity} of the atom. Intuiitively, $Y_0$ is the predicate name, and we thus also use the more familiar notation $Y_0(Y_1,...,Y_n)$. The atom is \textit{ordinary}, if $Y_0$ is a constant. For example, \textit{(x,rdf:type,c),node(X), and D(a,b),} are atoms;the first two are ordinary atoms. An \textit{external atom} is of the form \\ \centerline{ \&g[$Y_1,...,Y_n$]($X_1,...,X_m$),} \\where $Y_1,...,Y_n$ and $X_1,...,X_m$ are the two lists of terms(called \textit{input} and \textit{output} lists, respectively), and \&g $\in$ \textit{G} is an external predicate name. We assume that \&g has fixed lengths \textit{in(\&g)} = n and \textit{out(\&g)} = m for input and output lists, respectively. Intuitively, an external atom provides a way for deciding the truth value of an output tuple depending on the extension of a set of input predicates.       
\\To understand concept better we are providing example which show how we can get use of external atoms in ordinary ASP.
\\ \textbf{\\Example X.X.}
\\ \lstinputlisting{introductiontohex.hex}     
Above is \hex{} program  which works with constant input parameters  to external sources. For each system, it concatenates string "hello" and system name using \textbf{concat} external source. At the output we have something like: \textit{sayhello(hellodlvhex), sayhello(helloclasp)}. Last part of the program works with predicate input parameters. It first define two different sets and then computes set1 minus set2 using \textbf{setdiff} external source. External source definition is given below:
\lstinputlisting{extsource.py}
After this short example one can see how system is working and what are the advantages of \dlvhex{} over ordinary ASP solvers.  





\newpage
\section{References}
\begin{thebibliography}{1}
\bibitem{extatoms} Thomas Eiter, Micheal Fink, Thomas Krennwallner, Christoph Redl {\em Conflict-driven ASP Solving with External Sources} 2003   
  
\bibitem{ref} Francesco Calimeri, Wolfgang Faber, Martin Gebser, Giovambattista Ianni, Roland Kaminski, Thomas Krennwallner, Nicola leone, Francesco Ricca, Torsten Schaub {\em ASP-Core-2 Input Language} 2013.

\bibitem{licnc} GNU Lesser General Public License. Free Software Foundation, Inc. https://www.gnu.org/copyleft/lesser.html 

\bibitem{onlinedemo}dlvhex. Vienna University of Technology. http://www.kr.tuwien.ac.at/research/systems/dlvhex/demo.php 

\bibitem{git}Software for HEX-Programs. GitHub. https://github.com/hexhex/ 

\bibitem{sourceforge}DLVHEX solver for HEX-programs-  Browse Files at SourceForge.net. Sourceforge.net. http://sourceforge.net/projects/dlvhex/files/

\bibitem{prebuilt}KBS-ASP systems. Thomas Krenwallner. http://www.kr.tuwien.ac.at/staff/tkren/deb.html

\bibitem{boost}Boost C++ Libraries. Boost.org. http://www.boost.org/

\bibitem{hexhex}dlvhex. GitHub. https://github.com/hexhex/core

\bibitem{script}Web location for script

\bibitem{extatoms2}Thomas Eiter, Giovamattista Ianni, Roman Schindlauer and hans Tompits {\em A Uniform Integration of Higher-Order Reasoning and External Evaluations in Answer-Set Programming} 


\bibitem{pott}Martin Gebser, Roland Kaminski, Benjamin Kaufmann, Marius Lindauer, Max Ostrowski, Javier Romero, Trosten Schaub and Sven Thiele {\em Pottasco User Guide}

\bibitem{dlvum}Robert Bihlmeyer, Wolfgang Faber, Giuseppe Ielpa, Vincezino Lio and Gerald Pfeifer {\em DLV-User Manual} 
      
 
 \end{thebibliography} 



\end{document}

